---
title: First programming language
---

This question can come in many forms. "What programming language should I learn first?" Or "What programming language is trending at the moment?" (NB: "programming" in there specifically cuts off a very true, but probably not a very useful answer: English. But that's a story for another time.)

---

## Short answer

Understand **what you want to do** and instead ask what language does **that** the quickest.

## Sanity check

That's probably not what you actually want to know. It's not just a generic *"I just want to learn how to program"*.

If it is, I give you one more chance: ask yourself **why** you want to learn to program. If nothing comes up still, I actually have a very specific and short answer for you.

### **`don't`**

Because if you're learning something that doesn't have a purpose behind it, chances are you'll soon forget it and the time you spent learning was mostly _wasted_.

Not happy with this answer? Then there may be a reason behind that intention that you're just refusing to admit. In which case, read on, I might have a few hints.

## If there is a purpose

### Specific project

This is the easiest case to handle.

#### Fine-tuning

Got a very particular piece of hardware or software that accepts custom programs but doesn't do *exactly* what you want? Ask around, see how to get started with that particular thing. In such a specific area there is usually *one* preferred language/tool, and the comunity will likely point you in the right direction there.

#### Video game

Got a video game idea after playing something? Ok, [this can get tough easily](https://xkcd.com/1425/), because it's very easy to get _so_ enamored with the idea that everything in the way suddenly starts to seem insignificant. Including such petty nuisances like need for sustenance, your own initial incompetence and copyright.

But don't lose hope!

Depending on the game, you may not even have to get into programming to have a playable prototype. You can write out the rules and follow them, right? If yes, try simulating the game in form of a tabletop. If not, hold your horses and learn to do that first! Because programming is all about designing the rules and translating them so that someone else, or rather some**thing** else can understand.

If your type of game doesn't work so well as a tabletop (although a few trial runs may still be beneficial) or you're happy enough with it as a tabletop to make it real, then I guess it is time to pick a tool. There are many **game engines** out there, take your pick. But you'll be in for *a lot* of new material. You could try cutting a few corners and *building a mod for an existing game instead*, since in this scenario the bulk of the game is already built for you. Sure, a mod might not be commercially viable depending on how the developers look at things, but aiming for commercial success for your very first game is unrealistic anyway.

*[[TODO]] List more common scenarios?*

### Job / money

I won't judge you for this, since I don't know all the details.

But I will give you a fair warning: choosing a job based **solely** on income is a recipe for disaster. It is very likely to get you a job you'll eventually hate, but won't be able to easily change. And hating what you do will most certainly hurt your performance and end in burnout. And this may actually happen before you reach salary numbers you may have reached in other fields that you actually enjoy.

But if it's *one of several/many leading reasons* to get you into this field, then your answer lies somewhere in job listings. These vary by region and change over time, so you're going to have to do some research. You'll be doing a lot of research during the learning process, so this can serve as a decent warmup.

### Staying ahead of the curve

You need to understand the practical benefits of what you're doing. Because you're investing time into it, and you have a finite amount of time on your hands. You should expect some <abbr title="Return on Time Investment">ROTI</abbr>.

If you're not expecting any *specific* returns, there is a very fair chance that you'll get _nothing in return_. Why bother then?

But there is, of course, *a catch*. Being uninformed and being aware of it. We can probably both agree that interest in automation has skyrocketed, and automation usually involves programming in some shape or form, so it's safe to assume that knowledge of programming is going to be very beneficial going forward. Even if it's not exactly obvious right now how to apply this, it's an solid investment into one's future. Right?

But there is a catch *inside* that catch. As tooling evolves, it gets more accessible. So by the time you'll actually require automation, there is a fair chance that tooling will have evolved enough that you will not have to learn much in order to automate whatever it is you need.

So this is a [[balance]] where you just have to make the call. It's obviously not just two states of investing no time at all and going all the way in. If anything then because the latter is simply impossible. It's a question of how deep you want or need to go.

[[FAQ]]
